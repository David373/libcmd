package libcmd

import (
	"fmt"
)

// parsing: generic parser error
type parserError struct {
	arg string
	err error
}

func (e parserError) Error() string {
	if e.arg != "" {
		return fmt.Sprintf("error parsing argument '%s': %v", e.arg, e.err)
	}

	return fmt.Sprintf("parsing error: %v", e.err)
}

// parsing: unknown argument
type unknownArgErr struct {
	arg string
}

func (e unknownArgErr) Error() string {
	return fmt.Sprintf("unknown argument: %s", e.arg)
}

// parsing: no value for argument
type noValueErr struct {
	arg string
}

func (e noValueErr) Error() string {
	return fmt.Sprintf("no value for argument: %s", e.arg)
}

// parsing: conversion error
type conversionErr struct {
	value    interface{}
	typeName string
}

func (e conversionErr) Error() string {
	return fmt.Sprintf("'%v' is not a valid %s value", e.value, e.typeName)
}

// parsing: unsupported type
type unsupportedErr struct {
	value    interface{}
	typeName string
}

func (e unsupportedErr) Error() string {
	return fmt.Sprintf("unsupported type '%s' for value '%s'", e.typeName, e.value)
}

// parsing: wrong number of operands
type operandRequiredErr struct {
	required int
	got      int
	exact    bool
}

func (e operandRequiredErr) Error() string {
	if e.exact {
		return fmt.Sprintf("wrong number of operands, exactly %d required (got %d)", e.required, e.got)
	}
	return fmt.Sprintf("wrong number of operands, at least %d required (got %d)", e.required, e.got)
}

// IsParserErr returns true is the error is an error
// generated by the parsing process itself.
func IsParserErr(err error) bool {
	if err == nil {
		return false
	}

	switch err.(type) {
	case parserError:
		return true

	case unknownArgErr:
		return true

	case noValueErr:
		return true

	case conversionErr:
		return true

	case operandRequiredErr:
		return true

	default:
		return false
	}
}
